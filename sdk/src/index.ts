import * as anchor from '@coral-xyz/anchor';
import { Program, Idl } from '@coral-xyz/anchor';
import { PublicKey, SystemProgram, Connection, Commitment } from '@solana/web3.js';

// Import IDL - this will be generated by anchor build
// @ts-ignore - IDL is generated at build time
import EvidenceVaultIDL from './idl/evidence_vault.json';

// Re-export types from generated IDL
type EvidenceVault = typeof EvidenceVaultIDL;

export interface Case {
  investigator: PublicKey;
  caseId: string;
  title: string;
  description: string;
  status: CaseStatus;
  evidenceCount: number;
  reportHash: Uint8Array | null;
  createdAt: Date;
  updatedAt: Date;
}

export type CaseStatus = 'Open' | 'Closed' | 'Archived';

export interface Evidence {
  caseId: string;
  evidenceId: number;
  evidenceType: EvidenceType;
  dataHash: Uint8Array;
  metadataUri: string;
  description: string;
  submitter: PublicKey;
  timestamp: Date;
}

export type EvidenceType = 
  | 'TransactionTrace' 
  | 'WalletCluster' 
  | 'ThreatAlert' 
  | 'Report' 
  | 'External';

// IDL-defined event types
export interface CaseCreatedEvent {
  caseId: string;
  investigator: PublicKey;
  timestamp: anchor.BN;
}

export interface EvidenceAddedEvent {
  caseId: string;
  evidenceId: number;
  evidenceType: any; // IDL-defined enum
  submitter: PublicKey;
  timestamp: anchor.BN;
}

export interface CaseClosedEvent {
  caseId: string;
  reportHash: Uint8Array;
  timestamp: anchor.BN;
}

export interface FindingRecordedEvent {
  caseId: string;
  findingHash: Uint8Array;
  recorder: PublicKey;
  timestamp: anchor.BN;
}

// SDK Configuration
export interface ConstableSDKConfig {
  connection: Connection;
  wallet: anchor.Wallet;
  programId?: PublicKey;
  commitment?: Commitment;
}

// Error types
export class ForensicError extends Error {
  constructor(
    public code: string,
    message: string,
    public originalError?: any
  ) {
    super(message);
    this.name = 'ForensicError';
  }
}

export class ConstableSDK {
  private program: Program<EvidenceVault>;
  private connection: Connection;
  private provider: anchor.AnchorProvider;

  // Program ID constant - matches the Rust declare_id! macro
  public static readonly DEFAULT_PROGRAM_ID = new PublicKey('Fg6tVimZ4BRL1P8dWNFxDGWKdfnw3hH7VzMBz5v4RZJx');

  constructor(config: ConstableSDKConfig) {
    this.connection = config.connection;
    
    const commitment = config.commitment || 'confirmed';
    this.provider = new anchor.AnchorProvider(
      config.connection, 
      config.wallet, 
      { commitment }
    );
    anchor.setProvider(this.provider);
    
    const programId = config.programId || ConstableSDK.DEFAULT_PROGRAM_ID;
    
    // Load program from IDL
    this.program = new Program(
      EvidenceVaultIDL as unknown as EvidenceVault, 
      programId, 
      this.provider
    );
  }

  /**
   * Get the program instance for advanced usage
   */
  getProgram(): Program<EvidenceVault> {
    return this.program;
  }

  /**
   * Get the provider instance
   */
  getProvider(): anchor.AnchorProvider {
    return this.provider;
  }

  /**
   * Derive the case PDA address
   */
  getCasePda(caseId: string, investigator: PublicKey): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from('case'),
        Buffer.from(caseId),
        investigator.toBuffer()
      ],
      this.program.programId
    );
  }

  /**
   * Derive the evidence PDA address
   */
  getEvidencePda(caseId: string, evidenceId: number): [PublicKey, number] {
    return PublicKey.findProgramAddressSync(
      [
        Buffer.from('evidence'),
        Buffer.from(caseId),
        Buffer.from(new Uint32Array([evidenceId]).buffer)
      ],
      this.program.programId
    );
  }

  /**
   * Convert EvidenceType string to IDL format
   */
  private evidenceTypeToIdl(type: EvidenceType): any {
    const typeMap: Record<EvidenceType, any> = {
      'TransactionTrace': { transactionTrace: {} },
      'WalletCluster': { walletCluster: {} },
      'ThreatAlert': { threatAlert: {} },
      'Report': { report: {} },
      'External': { external: {} }
    };
    return typeMap[type];
  }

  /**
   * Convert IDL evidence type to string
   */
  private evidenceTypeFromIdl(idlType: any): EvidenceType {
    if (idlType.transactionTrace !== undefined) return 'TransactionTrace';
    if (idlType.walletCluster !== undefined) return 'WalletCluster';
    if (idlType.threatAlert !== undefined) return 'ThreatAlert';
    if (idlType.report !== undefined) return 'Report';
    if (idlType.external !== undefined) return 'External';
    throw new Error('Unknown evidence type');
  }

  /**
   * Convert case status IDL to string
   */
  private caseStatusFromIdl(idlStatus: any): CaseStatus {
    if (idlStatus.open !== undefined) return 'Open';
    if (idlStatus.closed !== undefined) return 'Closed';
    if (idlStatus.archived !== undefined) return 'Archived';
    throw new Error('Unknown case status');
  }

  /**
   * Create a new investigation case
   */
  async createCase(
    caseId: string,
    title: string,
    description: string
  ): Promise<{ signature: string; casePda: PublicKey }> {
    try {
      const investigator = this.provider.wallet.publicKey;
      const [casePda] = this.getCasePda(caseId, investigator);

      const signature = await this.program.methods
        .createCase(caseId, title, description)
        .accounts({
          case: casePda,
          investigator,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, casePda };
    } catch (error: any) {
      throw this.handleError(error, 'CREATE_CASE_FAILED');
    }
  }

  /**
   * Add evidence to a case
   */
  async addEvidence(
    casePda: PublicKey,
    evidenceType: EvidenceType,
    dataHash: Uint8Array | Buffer,
    metadataUri: string,
    description: string
  ): Promise<{ signature: string; evidencePda: PublicKey; evidenceId: number }> {
    try {
      const submitter = this.provider.wallet.publicKey;
      
      // Get case to determine evidence ID
      const caseAccount = await this.program.account.case.fetch(casePda);
      const evidenceId = caseAccount.evidenceCount;

      const [evidencePda] = this.getEvidencePda(caseAccount.caseId, evidenceId);

      const signature = await this.program.methods
        .addEvidence(
          this.evidenceTypeToIdl(evidenceType),
          Array.from(dataHash),
          metadataUri,
          description
        )
        .accounts({
          case: casePda,
          evidence: evidencePda,
          submitter,
          systemProgram: SystemProgram.programId,
        })
        .rpc();

      return { signature, evidencePda, evidenceId };
    } catch (error: any) {
      throw this.handleError(error, 'ADD_EVIDENCE_FAILED');
    }
  }

  /**
   * Close a case and store final report hash
   */
  async closeCase(
    casePda: PublicKey,
    reportHash: Uint8Array | Buffer
  ): Promise<{ signature: string }> {
    try {
      const investigator = this.provider.wallet.publicKey;

      const signature = await this.program.methods
        .closeCase(Array.from(reportHash))
        .accounts({
          case: casePda,
          investigator,
        })
        .rpc();

      return { signature };
    } catch (error: any) {
      throw this.handleError(error, 'CLOSE_CASE_FAILED');
    }
  }

  /**
   * Add a finding/memo to the case (immutable audit trail)
   */
  async addFinding(
    casePda: PublicKey,
    finding: string
  ): Promise<{ signature: string }> {
    try {
      const recorder = this.provider.wallet.publicKey;

      const signature = await this.program.methods
        .addFinding(finding)
        .accounts({
          case: casePda,
          recorder,
        })
        .rpc();

      return { signature };
    } catch (error: any) {
      throw this.handleError(error, 'ADD_FINDING_FAILED');
    }
  }

  /**
   * Fetch case details
   */
  async getCase(casePda: PublicKey): Promise<Case> {
    try {
      const account = await this.program.account.case.fetch(casePda);
      return {
        investigator: account.investigator,
        caseId: account.caseId,
        title: account.title,
        description: account.description,
        status: this.caseStatusFromIdl(account.status),
        evidenceCount: account.evidenceCount,
        reportHash: account.reportHash,
        createdAt: new Date(account.createdAt.toNumber() * 1000),
        updatedAt: new Date(account.updatedAt.toNumber() * 1000),
      };
    } catch (error: any) {
      throw this.handleError(error, 'FETCH_CASE_FAILED');
    }
  }

  /**
   * Fetch evidence details
   */
  async getEvidence(evidencePda: PublicKey): Promise<Evidence> {
    try {
      const account = await this.program.account.evidence.fetch(evidencePda);
      return {
        caseId: account.caseId,
        evidenceId: account.evidenceId,
        evidenceType: this.evidenceTypeFromIdl(account.evidenceType),
        dataHash: new Uint8Array(account.dataHash),
        metadataUri: account.metadataUri,
        description: account.description,
        submitter: account.submitter,
        timestamp: new Date(account.timestamp.toNumber() * 1000),
      };
    } catch (error: any) {
      throw this.handleError(error, 'FETCH_EVIDENCE_FAILED');
    }
  }

  /**
   * Fetch all evidence for a case
   */
  async getCaseEvidence(casePda: PublicKey): Promise<Evidence[]> {
    try {
      const caseAccount = await this.getCase(casePda);
      const evidences: Evidence[] = [];

      for (let i = 0; i < caseAccount.evidenceCount; i++) {
        const [evidencePda] = this.getEvidencePda(caseAccount.caseId, i);
        try {
          const evidence = await this.getEvidence(evidencePda);
          evidences.push(evidence);
        } catch (e) {
          // Skip if evidence account doesn't exist
          console.warn(`Evidence ${i} not found for case ${caseAccount.caseId}`);
        }
      }

      return evidences;
    } catch (error: any) {
      throw this.handleError(error, 'FETCH_CASE_EVIDENCE_FAILED');
    }
  }

  /**
   * Fetch all cases for an investigator
   */
  async getCasesByInvestigator(investigator: PublicKey): Promise<PublicKey[]> {
    try {
      const accounts = await this.connection.getProgramAccounts(
        this.program.programId,
        {
          filters: [
            {
              dataSize: 8 + 32 + 4 + 32 + 4 + 64 + 4 + 256 + 1 + 4 + 1 + 32 + 8 + 8 // Approximate size
            },
            {
              memcmp: {
                offset: 8, // After discriminator
                bytes: investigator.toBase58()
              }
            }
          ]
        }
      );
      return accounts.map(a => a.pubkey);
    } catch (error: any) {
      throw this.handleError(error, 'FETCH_INVESTIGATOR_CASES_FAILED');
    }
  }

  /**
   * Get all cases (paginated)
   */
  async getAllCases(limit?: number): Promise<{ pubkey: PublicKey; account: Case }[]> {
    try {
      const accounts = await this.connection.getProgramAccounts(
        this.program.programId,
        {
          dataSlice: { offset: 0, length: 0 }, // Fetch minimal data
          filters: [] // Could add filters here
        }
      );

      const results = [];
      const maxResults = limit || accounts.length;

      for (let i = 0; i < Math.min(accounts.length, maxResults); i++) {
        try {
          const caseAccount = await this.getCase(accounts[i].pubkey);
          results.push({ pubkey: accounts[i].pubkey, account: caseAccount });
        } catch (e) {
          // Skip invalid accounts
        }
      }

      return results;
    } catch (error: any) {
      throw this.handleError(error, 'FETCH_ALL_CASES_FAILED');
    }
  }

  /**
   * Subscribe to case events
   */
  onCaseCreated(callback: (event: CaseCreatedEvent, slot: number, signature: string) => void): number {
    return this.program.addEventListener('caseCreated', (event, slot, signature) => {
      callback(event as CaseCreatedEvent, slot, signature);
    });
  }

  onEvidenceAdded(callback: (event: EvidenceAddedEvent, slot: number, signature: string) => void): number {
    return this.program.addEventListener('evidenceAdded', (event, slot, signature) => {
      callback(event as EvidenceAddedEvent, slot, signature);
    });
  }

  onCaseClosed(callback: (event: CaseClosedEvent, slot: number, signature: string) => void): number {
    return this.program.addEventListener('caseClosed', (event, slot, signature) => {
      callback(event as CaseClosedEvent, slot, signature);
    });
  }

  onFindingRecorded(callback: (event: FindingRecordedEvent, slot: number, signature: string) => void): number {
    return this.program.addEventListener('findingRecorded', (event, slot, signature) => {
      callback(event as FindingRecordedEvent, slot, signature);
    });
  }

  /**
   * Remove event listener
   */
  removeEventListener(listenerId: number): Promise<void> {
    return this.program.removeEventListener(listenerId);
  }

  /**
   * Handle and transform errors
   */
  private handleError(error: any, code: string): ForensicError {
    // Extract error message from Anchor error
    let message = error.message || 'Unknown error';
    
    // Check for specific error codes from the program
    if (error.message?.includes('CaseClosed')) {
      message = 'Case is closed and cannot be modified';
      code = 'CASE_CLOSED';
    } else if (error.message?.includes('Unauthorized')) {
      message = 'Unauthorized action';
      code = 'UNAUTHORIZED';
    } else if (error.message?.includes('InvalidEvidenceType')) {
      message = 'Invalid evidence type';
      code = 'INVALID_EVIDENCE_TYPE';
    }

    return new ForensicError(code, message, error);
  }
}

// Convenience function for creating SDK instance
export function createConstableSDK(config: ConstableSDKConfig): ConstableSDK {
  return new ConstableSDK(config);
}

export default ConstableSDK;
